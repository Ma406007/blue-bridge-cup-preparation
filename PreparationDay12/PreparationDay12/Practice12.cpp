//第十四届蓝桥杯省赛C/C++大学B组E题
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;

//n:数列的长度 dp:用来获取输入的整数数列可以得到的接龙数列的最大长度 maxn:接龙数列的最大长度
int n, dp[10], maxn;
//为了方便取头尾可以以字符串形式存储
string a;
signed main() {
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> a;

		/*
		* 令dpi为以i结尾的最长序列,枚举到ai?时:
		*   设ai开头数字为p,结尾数字为q
		*   如果接龙数列内有ai,那么dpq=dpp+1;如果接龙数列内没有ai,那么dpq不变(即dpq=dpq)
		*   由上可得出动态规划转移方程:dpq=max(dpq,dpp+1)
		* 由此可以得出接龙数列的最大长度maxn
		* 最后再由数列的总长度n减去接龙数列的最大长度maxn即可得到要删除的数的个数
		*/
		int ln = a.length();
		/*
		* 更详细的原理解释:
		*   如果ai在接龙数列中,其开头数字会和上一个数字的结尾数字相同,其结尾数字会和下一个数字的开头数字相同
		*   如果ai不在接龙数列中,其开头数字或结尾数字不会与其两边的数字产生关联,或是均无关联
		* 因此对dp更准确的解释是:
		*   由于dp的长度为10,其值正好映射十进制数字0~9
		*   如果ai在接龙数列中,遍历时就可以将其加入接龙数列的队列中,dp下标映射的数字就是ai的结尾数字
		    --  此时会产生一个value值覆盖dp[a[ln-1]-'0'],这个值就是当前接龙数列的长度(即dpp+1,前一个数字加入接龙数列时的长度,依据此行同理)(加入ai后)
		*   如果ai不在接龙数列中,遍历时不可将其加入接龙数列的队列中,此时仍然会产生一个value值覆盖dp[a[ln-1]-'0'],这个值就是当前接龙数列的长度(即dpq,前一个数字加入接龙数列时的长度)(未加入ai,因为ai不符合接龙数列的条件)
		* 以此迭代后,就会得出接龙数列的最大长度
		*/
		dp[a[ln - 1] - '0'] = max(dp[a[ln - 1] - '0'], dp[a[0] - '0'] + 1);
	}
	//获取接龙数列的最大长度
	for (int i = 0; i <= 9; i++) {
		maxn = max(maxn, dp[i]);
	}
	cout << n - maxn << endl;
	return 0;
}